% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/query_api.R
\docType{class}
\name{QueryApi}
\alias{QueryApi}
\title{Query operations}
\format{
An \code{R6Class} generator object
}
\description{
influxdbclient.Query
}
\section{Methods}{

\describe{
\strong{ GetQuerySuggestions } \emph{  }


\itemize{
\item \emph{ @param } zap.trace.span character
\item \emph{ @returnType } \link{FluxSuggestions} \cr


\item status code : 200 | Suggestions for next functions in call chain

\item return type : FluxSuggestions 
\item response headers :

\tabular{ll}{
}
\item status code : 0 | Any response other than 200 is an internal server error

\item return type : Error 
\item response headers :

\tabular{ll}{
}
}

\strong{ GetQuerySuggestionsName } \emph{  }


\itemize{
\item \emph{ @param } name character
\item \emph{ @param } zap.trace.span character
\item \emph{ @returnType } \link{FluxSuggestion} \cr


\item status code : 200 | Suggestions for next functions in call chain

\item return type : FluxSuggestion 
\item response headers :

\tabular{ll}{
}
\item status code : 0 | Any response other than 200 is an internal server error

\item return type : Error 
\item response headers :

\tabular{ll}{
}
}

\strong{ PostQuery } \emph{ Query InfluxDB }


\itemize{
\item \emph{ @param } zap.trace.span character
\item \emph{ @param } accept.encoding Enum < [gzip, identity] > 
\item \emph{ @param } content.type Enum < [application/json, application/vnd.flux] > 
\item \emph{ @param } org character
\item \emph{ @param } org.id character
\item \emph{ @param } query \link{Query}


\item status code : 200 | Query results

\item return type : character 
\item response headers :

\tabular{ll}{
Content-Encoding \tab The Content-Encoding entity header is used to compress the media-type.  When present, its value indicates which encodings were applied to the entity-body \cr
Trace-Id \tab The Trace-Id header reports the request&#39;s trace ID, if one was generated. \cr
}
\item status code : 429 | Token is temporarily over quota. The Retry-After header describes when to try the read again.


\item response headers :

\tabular{ll}{
Retry-After \tab A non-negative decimal integer indicating the seconds to delay after the response is received. \cr
}
\item status code : 0 | Error processing query

\item return type : Error 
\item response headers :

\tabular{ll}{
}
}

\strong{ PostQueryAnalyze } \emph{ Analyze an InfluxQL or Flux query }


\itemize{
\item \emph{ @param } zap.trace.span character
\item \emph{ @param } content.type Enum < [application/json] > 
\item \emph{ @param } query \link{Query}
\item \emph{ @returnType } \link{AnalyzeQueryResponse} \cr


\item status code : 200 | Query analyze results. Errors will be empty if the query is valid.

\item return type : AnalyzeQueryResponse 
\item response headers :

\tabular{ll}{
}
\item status code : 0 | Internal server error

\item return type : Error 
\item response headers :

\tabular{ll}{
X-Influx-Error \tab Error string describing the problem \cr
X-Influx-Reference \tab Reference code unique to the error type \cr
}
}

\strong{ PostQueryAst } \emph{  }
Analyzes flux query and generates a query specification.

\itemize{
\item \emph{ @param } zap.trace.span character
\item \emph{ @param } content.type Enum < [application/json] > 
\item \emph{ @param } language.request \link{LanguageRequest}
\item \emph{ @returnType } \link{ASTResponse} \cr


\item status code : 200 | Abstract syntax tree of flux query.

\item return type : ASTResponse 
\item response headers :

\tabular{ll}{
}
\item status code : 0 | Any response other than 200 is an internal server error

\item return type : Error 
\item response headers :

\tabular{ll}{
}
}

}
}

\examples{
\dontrun{
####################  GetQuerySuggestions  ####################

library(influxdbclient)
var.zap.trace.span <- '{\"trace_id\":\"1\",\"span_id\":\"1\",\"baggage\":{\"key\":\"value\"}}' # character | OpenTracing span context

api.instance <- QueryApi$new()

result <- api.instance$GetQuerySuggestions(zap.trace.span=var.zap.trace.span)


####################  GetQuerySuggestionsName  ####################

library(influxdbclient)
var.name <- 'name_example' # character | The name of the branching suggestion.
var.zap.trace.span <- '{\"trace_id\":\"1\",\"span_id\":\"1\",\"baggage\":{\"key\":\"value\"}}' # character | OpenTracing span context

api.instance <- QueryApi$new()

result <- api.instance$GetQuerySuggestionsName(var.name, zap.trace.span=var.zap.trace.span)


####################  PostQuery  ####################

library(influxdbclient)
var.zap.trace.span <- '{\"trace_id\":\"1\",\"span_id\":\"1\",\"baggage\":{\"key\":\"value\"}}' # character | OpenTracing span context
var.accept.encoding <- 'identity' # character | The Accept-Encoding request HTTP header advertises which content encoding, usually a compression algorithm, the client is able to understand.
var.content.type <- 'content.type_example' # character | 
var.org <- 'org_example' # character | Specifies the name of the organization executing the query. Takes either the ID or Name interchangeably. If both `orgID` and `org` are specified, `org` takes precedence.
var.org.id <- 'org.id_example' # character | Specifies the ID of the organization executing the query. If both `orgID` and `org` are specified, `org` takes precedence.
var.query <- Query$new() # Query | Flux query or specification to execute

#Query InfluxDB
api.instance <- QueryApi$new()

result <- api.instance$PostQuery(zap.trace.span=var.zap.trace.span, accept.encoding=var.accept.encoding, content.type=var.content.type, org=var.org, org.id=var.org.id, query=var.query)


####################  PostQueryAnalyze  ####################

library(influxdbclient)
var.zap.trace.span <- '{\"trace_id\":\"1\",\"span_id\":\"1\",\"baggage\":{\"key\":\"value\"}}' # character | OpenTracing span context
var.content.type <- 'content.type_example' # character | 
var.query <- Query$new() # Query | Flux or InfluxQL query to analyze

#Analyze an InfluxQL or Flux query
api.instance <- QueryApi$new()

result <- api.instance$PostQueryAnalyze(zap.trace.span=var.zap.trace.span, content.type=var.content.type, query=var.query)


####################  PostQueryAst  ####################

library(influxdbclient)
var.zap.trace.span <- '{\"trace_id\":\"1\",\"span_id\":\"1\",\"baggage\":{\"key\":\"value\"}}' # character | OpenTracing span context
var.content.type <- 'content.type_example' # character | 
var.language.request <- LanguageRequest$new() # LanguageRequest | Analyzed Flux query to generate abstract syntax tree.

api.instance <- QueryApi$new()

result <- api.instance$PostQueryAst(zap.trace.span=var.zap.trace.span, content.type=var.content.type, language.request=var.language.request)


}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{apiClient}}{Handles the client-server communication.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{QueryApi$new()}}
\item \href{#method-GetQuerySuggestions}{\code{QueryApi$GetQuerySuggestions()}}
\item \href{#method-GetQuerySuggestionsWithHttpInfo}{\code{QueryApi$GetQuerySuggestionsWithHttpInfo()}}
\item \href{#method-GetQuerySuggestionsName}{\code{QueryApi$GetQuerySuggestionsName()}}
\item \href{#method-GetQuerySuggestionsNameWithHttpInfo}{\code{QueryApi$GetQuerySuggestionsNameWithHttpInfo()}}
\item \href{#method-PostQuery}{\code{QueryApi$PostQuery()}}
\item \href{#method-PostQueryWithHttpInfo}{\code{QueryApi$PostQueryWithHttpInfo()}}
\item \href{#method-PostQueryAnalyze}{\code{QueryApi$PostQueryAnalyze()}}
\item \href{#method-PostQueryAnalyzeWithHttpInfo}{\code{QueryApi$PostQueryAnalyzeWithHttpInfo()}}
\item \href{#method-PostQueryAst}{\code{QueryApi$PostQueryAst()}}
\item \href{#method-PostQueryAstWithHttpInfo}{\code{QueryApi$PostQueryAstWithHttpInfo()}}
\item \href{#method-clone}{\code{QueryApi$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryApi$new(apiClient)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GetQuerySuggestions"></a>}}
\if{latex}{\out{\hypertarget{method-GetQuerySuggestions}{}}}
\subsection{Method \code{GetQuerySuggestions()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryApi$GetQuerySuggestions(zap.trace.span = NULL, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GetQuerySuggestionsWithHttpInfo"></a>}}
\if{latex}{\out{\hypertarget{method-GetQuerySuggestionsWithHttpInfo}{}}}
\subsection{Method \code{GetQuerySuggestionsWithHttpInfo()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryApi$GetQuerySuggestionsWithHttpInfo(zap.trace.span = NULL, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GetQuerySuggestionsName"></a>}}
\if{latex}{\out{\hypertarget{method-GetQuerySuggestionsName}{}}}
\subsection{Method \code{GetQuerySuggestionsName()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryApi$GetQuerySuggestionsName(name, zap.trace.span = NULL, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-GetQuerySuggestionsNameWithHttpInfo"></a>}}
\if{latex}{\out{\hypertarget{method-GetQuerySuggestionsNameWithHttpInfo}{}}}
\subsection{Method \code{GetQuerySuggestionsNameWithHttpInfo()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryApi$GetQuerySuggestionsNameWithHttpInfo(name, zap.trace.span = NULL, ...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PostQuery"></a>}}
\if{latex}{\out{\hypertarget{method-PostQuery}{}}}
\subsection{Method \code{PostQuery()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryApi$PostQuery(
  zap.trace.span = NULL,
  accept.encoding = "identity",
  content.type = NULL,
  org = NULL,
  org.id = NULL,
  query = NULL,
  ...
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PostQueryWithHttpInfo"></a>}}
\if{latex}{\out{\hypertarget{method-PostQueryWithHttpInfo}{}}}
\subsection{Method \code{PostQueryWithHttpInfo()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryApi$PostQueryWithHttpInfo(
  zap.trace.span = NULL,
  accept.encoding = "identity",
  content.type = NULL,
  org = NULL,
  org.id = NULL,
  query = NULL,
  ...
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PostQueryAnalyze"></a>}}
\if{latex}{\out{\hypertarget{method-PostQueryAnalyze}{}}}
\subsection{Method \code{PostQueryAnalyze()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryApi$PostQueryAnalyze(
  zap.trace.span = NULL,
  content.type = NULL,
  query = NULL,
  ...
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PostQueryAnalyzeWithHttpInfo"></a>}}
\if{latex}{\out{\hypertarget{method-PostQueryAnalyzeWithHttpInfo}{}}}
\subsection{Method \code{PostQueryAnalyzeWithHttpInfo()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryApi$PostQueryAnalyzeWithHttpInfo(
  zap.trace.span = NULL,
  content.type = NULL,
  query = NULL,
  ...
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PostQueryAst"></a>}}
\if{latex}{\out{\hypertarget{method-PostQueryAst}{}}}
\subsection{Method \code{PostQueryAst()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryApi$PostQueryAst(
  zap.trace.span = NULL,
  content.type = NULL,
  language.request = NULL,
  ...
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PostQueryAstWithHttpInfo"></a>}}
\if{latex}{\out{\hypertarget{method-PostQueryAstWithHttpInfo}{}}}
\subsection{Method \code{PostQueryAstWithHttpInfo()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryApi$PostQueryAstWithHttpInfo(
  zap.trace.span = NULL,
  content.type = NULL,
  language.request = NULL,
  ...
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{QueryApi$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
